<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测试1</title>
      <link href="/posts/3c47b44b.html"/>
      <url>/posts/3c47b44b.html</url>
      
        <content type="html"><![CDATA[<h1 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h1>]]></content>
      
      
      <categories>
          
          <category> cat1 </category>
          
          <category> cat2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello,Hexo</title>
      <link href="/posts/c6fb831a.html"/>
      <url>/posts/c6fb831a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>hello hexo！ <em><strong>Start writing</strong></em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> cat1 </category>
          
          <category> cat2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Hello </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的STL常用操作及函数</title>
      <link href="/posts/a3f76817.html"/>
      <url>/posts/a3f76817.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1.位运算"></a>1.位运算</h3><ul><li><code>&amp;</code>与</li><li><code>|</code>或</li><li><code>~</code>非</li><li><code>^</code>异或</li><li><code>&gt;&gt;</code>右移</li><li><code>&lt;&lt;</code>左移</li></ul><blockquote><p><em><strong>常用操作</strong></em></p><ul><li>求x的第k位数字x&gt;&gt;k&amp;1</li><li>lowbit(x)&#x3D;x&amp;-x，（-a等价于~a+1）返回x的最后一位1。例：0010返回10，10000返回10000</li></ul></blockquote><h3 id="2-常用库函数"><a href="#2-常用库函数" class="headerlink" title="2.常用库函数"></a>2.常用库函数</h3><ol><li>reverse翻转(时间复杂度O(n))<ul><li>翻转一个vector<code>reverse(a.begin(),a.end())</code></li><li>翻转一个数组，元素存放在下标1~n：<code>reverse(a+1,a+1+n)</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span></span>;  </span><br><span class="line">    <span class="type">int</span> b[]=&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)cout&lt;&lt;a[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)cout&lt;&lt;a[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------------------------------&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">sizeof</span>(b)/<span class="built_in">sizeof</span>(<span class="type">int</span>);i++)cout&lt;&lt;b[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    <span class="built_in">reverse</span>(b,b+<span class="built_in">sizeof</span>(b)/<span class="built_in">sizeof</span>(<span class="type">int</span>));  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">sizeof</span>(b)/<span class="built_in">sizeof</span>(<span class="type">int</span>);i++)cout&lt;&lt;b[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>unique去重<ul><li>返回去重之后的尾迭代器(或指针)，仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器(或指针)的减法，可计算出去重后的元素个数。</li><li>把一个vector去重：<ul><li><code>int m=unique(a.begin(),a.end())-a.begin()</code></li></ul></li><li>把一个数组去重，元素存放在下标1~n：<ul><li><code>int m=unique(a+1,a+1+n)-(a+1)</code></li></ul></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>&#125;)</span></span>;  </span><br><span class="line">    <span class="type">int</span> m= <span class="built_in">unique</span>(a,a+<span class="number">7</span>)-a;  </span><br><span class="line">    cout&lt;&lt;m&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)cout&lt;&lt;a[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-------------------------------------&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>())-b.<span class="built_in">begin</span>();  </span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cout&lt;&lt;b[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用用法(获得去重后的数组)  </span></span><br><span class="line">b.<span class="built_in">erase</span>(<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>()),b.<span class="built_in">end</span>());  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:b)cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>random_shuffle随机打乱，用法与reverse相同<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span></span>;  </span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));  </span><br><span class="line">    <span class="built_in">random_shuffle</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:a)cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>sort：对两个迭代器(或指针)指定的部分进行快速排序，可以在第三个参数传入定义大小比较的函数，或者重载“小于号”运算符。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//a是否应该排在b的前面  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//return a&lt;b;//从小到大  </span></span><br><span class="line">    <span class="keyword">return</span> a&gt;b;<span class="comment">//从大到小  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span></span>;  </span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));  </span><br><span class="line">    <span class="built_in">random_shuffle</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:a)cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    <span class="comment">//从小到大排序  </span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:a)cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    <span class="comment">//从大到小排序  </span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:a)cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    <span class="comment">//按照自己定义的比较方式  </span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(), cmp);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:a)cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体排序的两种方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rec</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> x,y;  </span><br><span class="line">    <span class="comment">////第二种:把自定义的结构体vector排序，重载“小于号”运算符  </span></span><br><span class="line"><span class="comment">//    bool operator&lt;(const Rec &amp;t)const  </span></span><br><span class="line"><span class="comment">//    &#123;  </span></span><br><span class="line"><span class="comment">//        return x&lt;t.x;//按照x从小到大排序  </span></span><br><span class="line"><span class="comment">//    &#125;  </span></span><br><span class="line">&#125;a[<span class="number">5</span>];  </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Rec a,Rec b)</span><span class="comment">//a是否应该排在b的前面  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//第一种  </span></span><br><span class="line">    <span class="keyword">return</span> a.y&gt;b.y;<span class="comment">//按照y从大到小  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">    a[i].x=-i;  </span><br><span class="line">    a[i].y=i;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>,a[i].x,a[i].y);  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    <span class="built_in">sort</span>(a,a+<span class="number">5</span>, cmp);  </span><br><span class="line">    <span class="comment">//sort(a,a+5);  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>,a[i].x,a[i].y);  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>lower_bound&#x2F;upper_bound 二分<ul><li>lower_bound的第三个参数传入一个元素x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于x的元素的位置的迭代器（指针）。</li><li>upper_bound的用法和lower_bound大致相同，唯一的区别是查找第一个大于x的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。</li><li>在有序int数组（元素存放在下标1~n）中查找大于等于x的最小整数的下标:<code>int i=lower_bound(a+1,a+1+n,x)-a;</code></li><li>在有序<code>vector&lt;int&gt;</code>中查找小于等于x的最大整数(假设一定存在)<code>int y=*--upper_bound(a.begin(),a.end(),x);</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//数组  </span></span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;  </span><br><span class="line">    <span class="type">int</span> *p= <span class="built_in">lower_bound</span>(a,a+<span class="number">5</span>,<span class="number">3</span>);  </span><br><span class="line">    <span class="type">int</span> i= <span class="built_in">lower_bound</span>(a,a+<span class="number">5</span>,<span class="number">3</span>)-a;  </span><br><span class="line">    <span class="type">int</span> *q= <span class="built_in">upper_bound</span>(a,a+<span class="number">5</span>,<span class="number">3</span>);  </span><br><span class="line">    <span class="type">int</span> j= <span class="built_in">upper_bound</span>(a,a+<span class="number">5</span>,<span class="number">3</span>)-a;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*p:&quot;</span>&lt;&lt;*p&lt;&lt;endl; <span class="comment">// 3</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;i:&quot;</span>&lt;&lt;i&lt;&lt;endl;  <span class="comment">//2</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*q:&quot;</span>&lt;&lt;*q&lt;&lt;endl; <span class="comment">// 4</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;j:&quot;</span>&lt;&lt;j&lt;&lt;endl; <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">//vector  </span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it1= <span class="built_in">lower_bound</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),<span class="number">8</span>);  </span><br><span class="line">    <span class="type">int</span> x= <span class="built_in">lower_bound</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),<span class="number">8</span>)-b.<span class="built_in">begin</span>();  </span><br><span class="line">    <span class="keyword">auto</span> it2= <span class="built_in">upper_bound</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),<span class="number">8</span>);  </span><br><span class="line">    <span class="type">int</span> y= <span class="built_in">upper_bound</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),<span class="number">8</span>)-b.<span class="built_in">begin</span>();  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;it1:&quot;</span>&lt;&lt;*it1&lt;&lt;endl;  <span class="comment">//8</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;x:&quot;</span>&lt;&lt;x&lt;&lt;endl;  <span class="comment">//2</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;it2:&quot;</span>&lt;&lt;*it2&lt;&lt;endl;<span class="comment">//9  </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;y:&quot;</span>&lt;&lt;y&lt;&lt;endl;  <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习</title>
      <link href="/posts/c6fb831a.html"/>
      <url>/posts/c6fb831a.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL学习"><a href="#MySQL学习" class="headerlink" title="MySQL学习"></a>MySQL学习</h1><h2 id="SQL语言分类"><a href="#SQL语言分类" class="headerlink" title="SQL语言分类"></a>SQL语言分类</h2><ol><li>数据查询语言(DQL)，用以从表中获得数据，确定数据怎样在应用程序中给出。关键字<code>select</code>是DQL(也是所有SQL)用得最多的动词。<ul><li><code>select</code></li><li><code>from</code></li><li><code>where</code></li><li><code>order by</code></li><li><code>having</code></li></ul></li><li>数据操纵语言(DML)，其语句动词包括动词<code>insert</code>、<code>update</code>和<code>delete</code>，它们分别用于添加、修改和删除表中的行。<ul><li><code>insert</code>：添加数据</li><li><code>update</code>：更新数据</li><li><code>delete</code>：删除数据</li></ul></li><li>数据定义语言(DDL)，定义数据库对象语言，其语句包括动词<code>create</code>和<code>drop</code>等。<ul><li><code>create</code>：创建数据库对象</li><li><code>alter</code>：修改数据库对象</li><li><code>drop</code>：删除数据库对象</li></ul></li><li>数据控制语言(DCL)，它的语句通过<code>grant</code>或<code>revoke</code>获得许可，确定用户对数据库对象的访问。<ul><li><code>grant</code>：授予用户某种权限</li><li><code>revoke</code>：回收授予的某种权限</li></ul></li><li>事务控制语言(TCL)，它的语句能确保被DML语句影响的表的所有行及时得到更新。<ul><li><code>commit</code>：提交事务</li><li><code>rollback</code>：回滚事务</li><li><code>savepoint</code>：设置回滚点<blockquote><p><em><strong>注意</strong></em><br>数据操纵语言DML(<code>insert、update、delete</code>)针对表中的数据；<br>而数据定义语言DDL(<code>create、alter、drop</code>)针对数据库对象，比如数据库database、表table、索引index、视图view、存储过程procedure、触发器trigger。</p></blockquote></li></ul></li></ol><h2 id="SQL语言语法"><a href="#SQL语言语法" class="headerlink" title="SQL语言语法"></a>SQL语言语法</h2><ol><li>SQL语句不区分大小写，关键字建议大写。</li><li>SQL语句可以单行或多行书写，以分号结尾。</li></ol><h2 id="创建与删除数据库"><a href="#创建与删除数据库" class="headerlink" title="创建与删除数据库"></a>创建与删除数据库</h2><ol><li>使用DDL语句创建数据库<br> <code>create database 数据库名 default character set 字符编码;</code><br> 示例：<br> 创建一个test数据库，并查看该数据库，以及该数据库的编码。<br> 创建数据库：<br> <code>create database test default character set utf8;</code><br> 查看数据库：<br> <code>show databases;</code><br> 查看数据库编码： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> schema_name,default_character_set_name </span><br><span class="line"><span class="keyword">from</span> information_schema.schemata</span><br><span class="line"><span class="keyword">where</span> schema_name<span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>使用DDL语句删除数据库<br> <code>drop database 数据库名称</code><br> 示例：<br> 删除test数据库<br> <code>drop delete test</code></li></ol><h2 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h2><p>在创建表时，需要先选择数据库。<br><code>use 数据库名</code><br>示例：<br>创建一个名称为students的数据库，编码为utf8<br><code>create database students default character set utf8;</code><br>选择该数据库<br><code>use students;</code></p><h2 id="MySQL中的数据类型"><a href="#MySQL中的数据类型" class="headerlink" title="MySQL中的数据类型"></a>MySQL中的数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><table><thead><tr><th>MySQL数据类型</th><th>含义(有符号)</th></tr></thead><tbody><tr><td>tinyint(m)</td><td>1个字节范围(-128~127)</td></tr><tr><td>smallint(m)</td><td>2个字节范围(-32768~32767)</td></tr><tr><td>mediumint(m)</td><td>3个字节范围(-8388608~8388607)</td></tr><tr><td>int(m)</td><td>4个字节范围(-2147483648~2147483647)</td></tr><tr><td>bigint(m)</td><td>8个字节范围(+-9.22 * 10的18次方)</td></tr><tr><td>数值类型中的长度m是指显示长度，并不表示存储长度，只有字段指定<code>zerofill</code>时有用。</td><td></td></tr><tr><td>例如：<code>int(3)</code>如果实际值是2，如果列指定了<code>zerofill</code>，查询结果就是002，左边用0来填充。</td><td></td></tr></tbody></table><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><table><thead><tr><th>MySQL数据类型</th><th>含义</th></tr></thead><tbody><tr><td>float(m,d)</td><td>单精度浮点型8位精度(4字节)m总个数，d小数位,(m-d)整数位</td></tr><tr><td>double(m,d)</td><td>双精度浮点型16位精度(8字节)m总个数，d小数位,(m-d)整数位</td></tr></tbody></table><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><table><thead><tr><th>MySQL数据类型</th><th>含义</th></tr></thead><tbody><tr><td>char(n)</td><td>固定长度，最多255个字符</td></tr><tr><td>tinytext</td><td>可变长度，最多255个字符</td></tr><tr><td>varchar(n)</td><td>可变长度，最多65535个字符</td></tr><tr><td>text</td><td>可变长度，最多65535个字符</td></tr><tr><td>mediumtext</td><td>可变长度，最多2的24次方-1个字符</td></tr><tr><td>longtext</td><td>可变长度，最多2的32次方-1个字符</td></tr></tbody></table><blockquote><p><em><strong>char和varchar：</strong></em></p><ol><li>char长度固定，即每条数据占用等长字节空间；适合用在身份证号码、手机号码等定长。</li><li>varchar可变长度，可以设置最大长度；适合用在长度可变的属性。</li><li>text不设置长度，当不知道属性的最大长度时，适合用text。<br><em>按照查询速度：char最快，varchar次之，text最慢。</em></li></ol></blockquote><p><strong>字符串使用建议：</strong></p><ol><li>经常变化的字段用varchar</li><li>知道固定长度的用char</li><li>尽量用carchar</li><li>超过255字符的只能用varchar或者text</li><li>能用varchar的地方不用text</li></ol><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><table><thead><tr><th>MySQL数据类型</th><th>含义</th></tr></thead><tbody><tr><td>date</td><td>日期YYYY-MM–DD</td></tr><tr><td>time</td><td>时间HH:MM:SS</td></tr><tr><td>datetime</td><td>日期时间YYYY-MM-DD HH:MM:SS</td></tr><tr><td>timestamp</td><td>时间戳YYYYMMDD HHMMSS</td></tr></tbody></table><h3 id="二进制数据-BLOB"><a href="#二进制数据-BLOB" class="headerlink" title="二进制数据(BLOB)"></a>二进制数据(BLOB)</h3><ol><li>blob和text存储方式不同，text以文本方式存储，英文存储区分大小写，而blob是以二进制方式存储，不区分大小写。</li><li>blob存储的数据只能整体读出。</li><li>text可以指定字符集，blob不用指定字符集。</li></ol><h2 id="创建表与删除表"><a href="#创建表与删除表" class="headerlink" title="创建表与删除表"></a>创建表与删除表</h2><ol><li>使用DDL语句创建表<br> <code>create table 表名(列名 类型,列名,类型......);</code><br> 示例：<br> 创建一个employees表包含雇员id，雇员名字，雇员薪水。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employees(employee_id <span class="type">int</span>,employee_name <span class="type">varchar</span>(<span class="number">10</span>),salary <span class="type">float</span>(<span class="number">8</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure> 查看已创建的表。<br> <code>show tables;</code></li><li>使用DDL语句删除表<br> <code>drop table 表名;</code><br> 示例：<br> 删除employees表。<br> <code>drop table employees;</code></li></ol><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><ol><li>使用DDL语句修改表<br> <code>alter table 旧表名 rename 新表名;</code><br> 示例一：<br> 创建一个employees表包含雇员id、雇员名字、雇员薪水。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employees(employee_id <span class="type">int</span>,employee_name <span class="type">varchar</span>(<span class="number">10</span>),salary <span class="type">float</span>(<span class="number">8</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure> 将employees表名修改为emp <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> employees rename emp;</span><br></pre></td></tr></table></figure></li></ol><h3 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h3><ol><li>使用DDL语句修改列名<br> <code>alter table 表名 change column 旧列名 新列名 类型;</code><br> 示例：<br> 将emp表中的employee_name修改为name <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp </span><br><span class="line">change <span class="keyword">column</span> employee_name name <span class="type">varchar</span>(<span class="number">20</span>);  </span><br></pre></td></tr></table></figure><blockquote><p><em><strong>注意：</strong></em> 即使新列名的类型不变，sql语句中也需要指明类型。</p></blockquote></li></ol><h3 id="修改列类型"><a href="#修改列类型" class="headerlink" title="修改列类型"></a>修改列类型</h3><ol><li>使用DDL语句修改列类型<br> <code>alter table 表名 modify 列名 新类型;</code><br> 示例：<br> 将emp中的name的长度指定位40. <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp modify name <span class="type">varchar</span>(<span class="number">40</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="添加新列"><a href="#添加新列" class="headerlink" title="添加新列"></a>添加新列</h3><ol><li>使用DDL语句添加新列<br> <code>alter table 表名 add column 新列名 类型;</code><br> 示例：<br> 在emp表中添加佣金列，列名为commission_pct。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">column</span> commission_pct <span class="type">float</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="删除指定列"><a href="#删除指定列" class="headerlink" title="删除指定列"></a>删除指定列</h3><ol><li>使用DDL语句删除指定列<br> <code>alter table 表名 drop column 列名;</code><br> 示例：<br> 删除emp表中的commission_pct。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">column</span> commission_pct;</span><br></pre></td></tr></table></figure></li></ol><h2 id="MySQL中的约束"><a href="#MySQL中的约束" class="headerlink" title="MySQL中的约束"></a>MySQL中的约束</h2><p>约束：数据库约束是对表中的数据进行进一步的限制，保证数据的正确性、有效性和完整性。</p><ol><li>主键约束(PK:primary key)<ol><li>不允许为空</li><li>不允许有重复值出现</li><li>保证数据的唯一性<blockquote><p>主键约束是使用最频繁的约束，在设计数据表时，一般情况下，都会要求标准设置一个主键。<br>主键是表的一个特殊字段，该字段能唯一标识该表中的每条信息。例如，学生信息表中的学号是唯一的。</p></blockquote></li></ol></li><li>外键约束(FK:foreign key)<ol><li>允许有空值</li><li>允许有重复</li><li>值必须是参照表的参照列中所包含的值</li><li>保证数据的参照完整性<blockquote><p>外键约束经常和主键约束一起使用，用来确保数据的一致性。</p></blockquote></li></ol></li><li>唯一性约束(Unique)<ol><li>相同值只能出现一次</li><li>允许为多个列添加唯一性约束</li><li>保证数据的唯一性<blockquote><p>唯一性约束与主键约束有一个相似的地方，就是它们都能够确保列的唯一性。与主键约束不同的是，唯一性约束在一个表中可以有多个，并且设置唯一性约束的列是允许有空值的。</p></blockquote></li></ol></li><li>非空约束(Not Null)<ol><li>列中不能有空值</li><li>允许重复值</li><li>允许为多个列添加非空约束</li><li>保证数据没有空值<blockquote><p>非空约束用来约束表中的字段不能为空。</p></blockquote></li></ol></li><li>检查约束(Check)<ol><li>用户自己定义约束条件</li><li>保证数据满足自定义的条件约束</li><li>MySQL目前不支持检查约束<blockquote><p>检查约束也叫用户自定义约束，是用来检查数据表中，字段值是否有效的一个手段，但目前MySQL数据库不支持检查约束。</p></blockquote></li></ol></li></ol><h3 id="主键约束-PK"><a href="#主键约束-PK" class="headerlink" title="主键约束(PK)"></a>主键约束(PK)</h3><ol><li>单一主键：使用一个列作为主键列，当该列的值有重复时，则违反唯一约束。</li><li>联合主键：使用多个列作为主键列，当多个列的值都相同时，则违反唯一约束。</li></ol><h4 id="修改表添加主键约束"><a href="#修改表添加主键约束" class="headerlink" title="修改表添加主键约束"></a>修改表添加主键约束</h4><ol><li>使用DDL语句添加主键约束<br> <code>alter table 表名 add primary key(列名);</code><br> 示例：<br> 将emp表中的employee_id修改为主键 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">primary</span> key(employee_id);</span><br></pre></td></tr></table></figure><ul><li><em><strong>主键自增长</strong></em><br>  MySQL中的自动增长类型要求：<ul><li>一个表中只能有一个列为自动增长。</li><li>自动增长的列的类型必须是整数类型。</li><li>自动增长只能添加到具备主键约束与唯一性约束的列上。</li><li>删除主键约束或唯一性约束，如果该列拥有自动增长能力，则需要先去掉自动增长然后在删除约束。  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 主键 类型 auto_increment;</span><br></pre></td></tr></table></figure>  示例：<br>  将emp表中的employee_id主键修改为自增。  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp modify employee_id <span class="type">int</span> auto_increment;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h4 id="删除主键约束"><a href="#删除主键约束" class="headerlink" title="删除主键约束"></a>删除主键约束</h4><ol><li>使用DDL语句删除主键约束<br> <code>alter table 表名 drop primary key;</code><blockquote><p><em><strong>注意：</strong></em><br>删除主键时，如果主键列具备自动增长能力，需要先去掉自动增长，然后在删除主键。</p></blockquote> 示例：<br> 删除emp表中的employee_id主键约束<br> 去掉自动增长：<br> <code>alter table emp modify employee_id int;</code><br> 删除主键:<br> <code>alter table emp drop primary key;</code></li></ol><h3 id="外键约束-FK"><a href="#外键约束-FK" class="headerlink" title="外键约束(FK)"></a>外键约束(FK)</h3><h4 id="修改表添加外键约束"><a href="#修改表添加外键约束" class="headerlink" title="修改表添加外键约束"></a>修改表添加外键约束</h4><ol><li>使用DDL语句添加外键约束<br> <code>alter table 表名 add constraint 约束名 foreign key(列名) references 参照的表名(参照的列名);</code><br> 示例一：<br> 创建departments表包含department_id、department_name、location_id。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> departments(department_id <span class="type">int</span>,department_name <span class="type">varchar</span>(<span class="number">30</span>),location_id      <span class="type">int</span> );</span><br></pre></td></tr></table></figure> 示例二：<br> 修改departments表，向departments_id列添加主键约束与自动递增(外键一般参照列都是参照表的主键列)。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> departments <span class="keyword">add</span> <span class="keyword">primary</span> key(department_id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> departments modify department_id <span class="type">int</span> auto_increment;</span><br></pre></td></tr></table></figure> 示例三：<br> 修改emp表，添加dept_id列。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">column</span> dept_id <span class="type">int</span>;</span><br></pre></td></tr></table></figure> 示例四：<br>  向emp表中的dept_id列添加外键约束。  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> emp_fk <span class="keyword">foreign</span> key(dept_id)</span><br><span class="line"><span class="keyword">references</span> departments(department_id);</span><br></pre></td></tr></table></figure></li></ol><h4 id="删除外键约束"><a href="#删除外键约束" class="headerlink" title="删除外键约束"></a>删除外键约束</h4><ol><li>使用DDL语句删除外键约束<br> <code>alter table 表名 drop foreign key 约束名;</code><br> 示例：<br> 删除dept_id的外键约束<br> <code>alter table emp drop foreign key emp_fk;</code></li></ol><h3 id="唯一性约束-Unique"><a href="#唯一性约束-Unique" class="headerlink" title="唯一性约束(Unique)"></a>唯一性约束(Unique)</h3><h4 id="修改表添加唯一性约束"><a href="#修改表添加唯一性约束" class="headerlink" title="修改表添加唯一性约束"></a>修改表添加唯一性约束</h4><p><img src="https://raw.githubusercontent.com/lujuny/picodemo/main/img/%E6%9C%AA%E5%AE%8C.jpg" alt="未完.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/posts/b8b0eacd.html"/>
      <url>/posts/b8b0eacd.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/lujuny/picodemo/main/img/325_ROG-Prism.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
